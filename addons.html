<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <title>Miapi-node por Nacho Pacheco</title>
  </head>
  <body>
    <header>
      <div class="container">
        <h1>Miapi-node</h1>
        <h2>Mi interpretación de la API de Node v0.8.8</h2>
      </div>
    </header>
    <div class="container">
      <section id="main_content">
<h1><abbr title="Addons">Agregados</abbr> C/C++</h1>

<p>Los <abbr title="addons">agregados</abbr> son objetos compartidos enlazados dinámicamente. Ellos pueden proveer el pegamento entre las bibliotecas C y C++. La <abbr title="Interfaz para Programar la Aplicación">API</abbr> (en estos momentos) es algo compleja, debido a que implica el conocimiento de varias bibliotecas.</p>

<ul>
<li><p>V8 JavaScript, una biblioteca C++. Usada como interfaz con JavaScript:
crea objetos, llama funciones, etc.  Documentada extensamente en el archivo de cabecera <code>v8.h</code> (<code>deps/v8/include/v8.h</code> en el árbol fuente de Node), que además está disponible <a href="http://izs.me/v8-docs/main.html">en línea</a>.</p></li>
<li><p><a href="https://github.com/joyent/libuv">libev</a>, biblioteca del bucle de eventos C. En cualquier momento que necesites esperar a que sea legible el descriptor de un archivo, esperar un temporizador, o esperar para recibir una señal, necesitarás usar la interfaz con <code>libuv</code>. Esto es, si realizas alguna E/S, necesitarás usar <code>libuv</code>.</p></li>
<li><p>Bibliotecas internas de Node. La clase más importante es <code>node::ObjectWrap</code> de la cual probablemente querrás derivar.</p></li>
<li><p>Otras. Busca en <code>deps/</code> para ver qué más hay disponible.</p></li>
</ul>

<p>Node compila estáticamente todas sus dependencias en el ejecutable. Cuándo compilas tu módulo, no tienes que preocuparte de enlazar a ninguna de esas bibliotecas.</p>

<h2>Hola mundo</h2>

<p>Para empezar haremos un pequeño agregado que es el equivalente C++ del siguiente código JavaScript:</p>

<pre><code>exports.hola = function () { return 'mundo'; };
</code></pre>

<p>Primero creamos un archivo <code>hola.cc</code>:</p>

<pre><code>#include &lt;node.h&gt;
#include &lt;v8.h&gt;

using namespace v8;

Handle&lt;Value&gt; Method(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New('mundo'));
}

void init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol('hola''),
      FunctionTemplate::New(Method)-&gt;GetFunction());
}
NODE_MODULE(hola, init)
</code></pre>

<p>Ten en cuenta que todos los <abbr title="addons">agregados</abbr> de Node tienen que exportar una función de inicio:</p>

<pre><code>void Initialize (Handle&lt;Object&gt; target);
NODE_MODULE(nombre_modulo, Initialize)
</code></pre>

<p>No hay un punto y coma después de <code>NODE_MODULE</code> puesto que no es una función (ve <code>node.h</code>).</p>

<p>El <code>nombre_modulo</code> necesita coincidir con el nombre del archivo binario final (sin el sufijo <code>.node</code>).</p>

<p>El código fuente se tiene que construir en <code>hola.node</code>, el agregado binario. Para ello creamos un archivo llamado <code>binding.gyp</code> en un formato similar a JSON, describiendo la configuración para construir tu módulo. Este archivo es compilado por <a href="https://github.com/TooTallNate/node-gyp">node-gyp</a>.</p>

<pre><code>{
  'targets': [
    {
      'target_name': 'hola',
      'sources': [ 'hola.cc' ]
    }
  ]
}
</code></pre>

<p>El siguiente paso es generar los archivos del proyecto adecuados para el ambiente actual. Para ello usa <code>node-gyp configure</code>.</p>

<p>Ahora tendrás o bien, un archivo <code>Makefile</code> (en ambientes Unix) o, un archivo <code>vcxproj</code> (en Windows) en el directorio <code>build/</code>. A continuación invoca la orden <code>node-gyp build</code>.</p>

<p>¡Ahora tienes compilado tu archivo de enlaces <code>.node</code>! Los enlaces compilados terminan en <code>build/Release/</code>.</p>

<p>Ahora puedes utilizar el agregado binario en el proyecto Node <code>hola.js</code>, apunta <code>require</code> al módulo <code>hola.node</code> recién construido:</p>

<pre><code>var agregado = require('./build/Release/hola');

console.log(agregado.hola()); // 'mundo'
</code></pre>

<p>Por favor, ve los patrones abajo para más información o consulta <a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a> para un ejemplo en producción.</p>

<h2>Patrones de agregados</h2>

<p>Abajo hay algunos patrones de agregados para ayudarte a empezar. Consulta en línea la <a href="http://izs.me/v8-docs/main.html">referencia de v8</a> para ayudarte con las diversas llamadas a v8, y la <a href="http://code.google.com/apis/v8/embed.html">Guía de incorporadores v8</a> para una explicación de varios conceptos utilizados, tal como controladores, ámbitos, plantillas de función, etc.</p>

<p>Para utilizar estos ejemplos necesitas compilarlos utilizando <code>node-gyp</code>.
Crea el siguiente archivo <code>binding.gyp</code>:</p>

<pre><code>{
  'targets': [
    {
      'target_name': 'agregado',
      'sources': [ 'agregado.cc' ]
    }
  ]
}
</code></pre>

<p>En los casos donde hay más de un archivo <code>.cc</code>, simplemente añade el nombre del archivo al arreglo <code>sources</code>, por ejemplo:</p>

<pre><code>'sources': ['agregado.cc', 'miejemplo.cc']
</code></pre>

<p>Ahora que tienes listo tu <code>binding.gyp</code>, puedes configurar y construir el agregado:</p>

<pre><code>$ node-gyp configure build
</code></pre>

<h3>Argumentos de función</h3>

<p>El siguiente patrón ilustra cómo leer los argumentos de llamadas a funciones JavaScript y devolver un resultado. Este es el <code>agregado.cc</code> principal y única fuente necesaria:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; Suma(const Arguments&amp; args) {
  HandleScope scope;

  if (args.Length() &lt; 2) {
    ThrowException(Exception::TypeError(String::New('Número de argumentos incorrecto')));
    return scope.Close(Undefined());
  }

  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {
    ThrowException(Exception::TypeError(String::New('Argumentos incorrectos')));
    return scope.Close(Undefined());
  }

  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +
      args[1]-&gt;NumberValue());
  return scope.Close(num);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol('suma'),
      FunctionTemplate::New(Suma)-&gt;GetFunction());
}

NODE_MODULE(agregado, Init)
</code></pre>

<p>Lo puedes probar con el siguiente fragmento de código JavaScript:</p>

<pre><code>var agregado = require('./build/Release/agregado');

console.log('Este debe ser ocho: ', agregado.suma(3, 5));
</code></pre>

<h3><abbr title="Callbacks">Retrollamadas</abbr></h3>

<p>Puedes pasar funciones JavaScript a una función C++ y ejecutarlas desde allí. Aquí tienes el <code>agregado.cc</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; EjecutaRetrollamada(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Function&gt; rt = Local&lt;Function&gt;::Cast(args[0]);
  const unsigned argc = 1;
  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New('hola mundo')) };
  rt-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);

  return scope.Close(Undefined());
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol('ejecutaRetrollamada'),
      FunctionTemplate::New(EjecutaRetrollamada)-&gt;GetFunction());
}

NODE_MODULE(agregado, Init)
</code></pre>

<p>Para probarlo ejecuta el siguiente fragmento de código JavaScript:</p>

<pre><code>var agregado = require('./build/Release/agregado');

agregado.ejecutaRetrollamada(function (mensaje) {
  console.log(mensaje); // 'hola mundo'
});
</code></pre>

<h3>Fábrica de objetos</h3>

<p>Puedes crear y devolver nuevos objetos dentro de una función C++ con este patrón <code>agregado.cc</code>, el cual regresa un objeto con una propiedad <abbr title="msg"><code>mensaje</code></abbr> que repite la cadena pasada a <code>createObject()</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;Object&gt; obj = Object::New();
  obj-&gt;Set(String::NewSymbol('mensaje'), args[0]-&gt;ToString());

  return scope.Close(objeto);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol('createObject'),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(agregado, Init)
</code></pre>

<p>Para probarlo en JavaScript:</p>

<pre><code>var agregado = require('./build/Release/agregado');

var obj1 = agregado.createObject('hola');
var obj2 = agregado.createObject('mundo');
console.log(obj1.mensaje + ' ' + obj2.mensaje); // 'hola mundo'
</code></pre>

<h3>Fábrica de función</h3>

<p>Este patrón ilustra cómo crear y devolver una función JavaScript que envuelve a una función C++:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;

using namespace v8;

Handle&lt;Value&gt; MiFuncion(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New('hola mundo'));
}

Handle&lt;Value&gt; CreaFuncion(const Arguments&amp; args) {
  HandleScope scope;

  Local&lt;FunctionTemplate&gt; plantilla = FunctionTemplate::New(MiFuncion);
  Local&lt;Function&gt; funcion = plantilla-&gt;GetFunction ();
  funcion-&gt;SetName(String::NewSymbol('laFuncion')); // omite esto para que sea anónimo

  return scope.Close(funcion);
}

void Init(Handle&lt;Object&gt; target) {
  target-&gt;Set(String::NewSymbol('creaFuncion'),
      FunctionTemplate::New(CreaFuncion)-&gt;GetFunction());
}

NODE_MODULE(agregado, Init)
</code></pre>

<p>Para probarlo:</p>

<pre><code>var agregado = require('./build/Release/agregado');

var funcion = agregado.creaFuncion();
console.log(funcion()); // 'hola mundo'
</code></pre>

<h3>Envolviendo objetos C++</h3>

<p>Aquí crearemos una envoltura para un objeto C++/clase <code>MiObjeto</code> del cual puedes crear instancias en JavaScript a través del operador <code>new</code>. Primero prepara el módulo principal <code>agregado.cc</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

void InitAll(Handle&lt;Object&gt; target) {
  MiObjeto::Init(target);
}

NODE_MODULE(agregado, InitAll)
</code></pre>

<p>Luego en <code>miobjeto.h</code>, haz que tu envoltura herede de <code>node::ObjectWrap</code>:</p>

<pre><code>#ifndef MIOBJETO_H
#define MIOBJETO_H

#include &lt;node.h&gt;

class MiObjeto : public node::ObjectWrap {
 public:
  static void Init(v8::Handle&lt;v8::Object&gt; target);

 private:
  MiObjeto();
  ~MiObjeto();

  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; SumaUno(const v8::Arguments&amp; args);
  double counter_;
};

#endif
</code></pre>

<p>Y en <code>miobjeto.cc</code> implementa los distintos métodos que quieres exponer.
Aquí exponemos el método <code>sumaUno</code> añadiéndolo al prototipo del constructor:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

MiObjeto::MiObjeto() {};
MiObjeto::~MiObjeto() {};

void MiObjeto::Init(Handle&lt;Object&gt; target) {
  // Prepara la plantilla del constructor
  Local&lt;FunctionTemplate&gt; plantilla = FunctionTemplate::New(New);
  plantilla-&gt;SetClassName(String::NewSymbol('MiObjeto'));
  plantilla-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototipo
  plantilla-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol('sumaUno'),
      FunctionTemplate::New(SumaUno)-&gt;GetFunction());

  Persistent&lt;Function&gt; constructor = Persistent&lt;Function&gt;::New(plantilla-&gt;GetFunction ());
  target-&gt;Set(String::NewSymbol('MiObjeto'), constructor);
}

Handle&lt;Value&gt; MiObjeto::New(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* objeto = new MiObjeto();
  objeto-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  objeto-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MiObjeto::SumaUno(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* objeto = ObjectWrap::Unwrap&lt;MiObjeto&gt;(args.This());
  objeto-&gt;counter_ += 1;

  return scope.Close(Number::New(objeto-&gt;counter_));
}
</code></pre>

<p>Lo puedes probar con:</p>

<pre><code>var agregado = require('./build/Release/agregado');

var objeto = new agregado.MiObjeto(10);
console.log(objeto.sumaUno()); // 11
console.log(objeto.sumaUno()); // 12
console.log(objeto.sumaUno()); // 13
</code></pre>

<h3>Fábrica de objetos envueltos</h3>

<p>Esta es útil cuando quieres poder crear objetos nativos sin crear instancias explícitamente con el operador <code>new</code> en JavaScript, por ejemplo:</p>

<pre><code>var objeto = agregado.createObject();
// en lugar de:
// var objeto = new agregado.Object();
</code></pre>

<p>Nos permite registrar nuestro método <code>createObject</code> en <code>agregado.cc</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MiObjeto::NewInstance(args));
}

void InitAll(Handle&lt;Object&gt; target) {
  MiObjeto::Init();

  target-&gt;Set(String::NewSymbol('createObject'),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());
}

NODE_MODULE(agregado, InitAll)
</code></pre>

<p>En <code>miobjeto.h</code> ahora introdujimos el método estático <code>NewInstance</code> el cual se encarga de crear instancias del objeto (es decir, hace el trabajo de <code>new</code> en JavaScript):</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MIOBJETO_H
#define MIOBJETO_H

#include &lt;node.h&gt;

class MiObjeto : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);

 private:
  MiObjeto();
  ~MiObjeto();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  static v8::Handle&lt;v8::Value&gt; SumaUno(const v8::Arguments&amp; args);
  double counter_;
};

#endif
</code></pre>

<p>La implementación es similar a la anterior en <code>miobjeto.cc</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

MiObjeto::MiObjeto() {};
MiObjeto::~MiObjeto() {};

Persistent&lt;Function&gt; MiObjeto::constructor;

void MiObjeto::Init() {
  // Prepara la plantilla del constructor
  Local&lt;FunctionTemplate&gt; plantilla = FunctionTemplate::New(New);
  plantilla-&gt;SetClassName(String::NewSymbol('MiObjeto'));
  plantilla-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);
  // Prototipo
  plantilla-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol('sumaUno'),
      FunctionTemplate::New(SumaUno)-&gt;GetFunction());

  constructor = Persistent&lt;Function&gt;::New(plantilla-&gt;GetFunction ());
}

Handle&lt;Value&gt; MiObjeto::New(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* objeto = new MiObjeto();
  objeto-&gt;counter_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  objeto-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MiObjeto::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}

Handle&lt;Value&gt; MiObjeto::SumaUno(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* objeto = ObjectWrap::Unwrap&lt;MiObjeto&gt;(args.This());
  objeto-&gt;counter_ += 1;

  return scope.Close(Number::New(objeto-&gt;counter_));
}
</code></pre>

<p>Lo puedes probar con:</p>

<pre><code>var agregado = require('./build/Release/agregado');

var objeto = agregado.createObject(10);
console.log(objeto.sumaUno()); // 11
console.log(objeto.sumaUno()); // 12
console.log(objeto.sumaUno()); // 13

var obj2 = agregado.createObject(20);
console.log(obj2.sumaUno()); // 21
console.log(obj2.sumaUno()); // 22
console.log(obj2.sumaUno()); // 23
</code></pre>

<h3>Pasando objetos envueltos</h3>

<p>Además de envolver y devolver objetos C++,  los puedes pasar desenvolviéndolos con la función auxiliar <code>node::ObjectWrap::Unwrap</code>.
En el siguiente <code>agregado.cc</code> introduciremos una función <code>suma()</code> que puede tomar dos objetos <code>MiObjeto</code>:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

Handle&lt;Value&gt; CreateObject(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(MiObjeto::NewInstance(args));
}

Handle&lt;Value&gt; Suma(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* obj1 = node::ObjectWrap::Unwrap&lt;MiObjeto&gt;(
      args[0]-&gt;AObjeto());
  MiObjeto* obj2 = node::ObjectWrap::Unwrap&lt;MiObjeto&gt;(
      args[1]-&gt;AObjeto());

  double suma = obj1-&gt;Val() + obj2-&gt;Val();
  return scope.Close(Number::New(suma));
}

void InitAll(Handle&lt;Object&gt; target) {
  MiObjeto::Init();

  target-&gt;Set(String::NewSymbol('createObject'),
      FunctionTemplate::New(CreateObject)-&gt;GetFunction());

  target-&gt;Set(String::NewSymbol('suma'),
      FunctionTemplate::New(Suma)-&gt;GetFunction());
}

NODE_MODULE(agregado, InitAll)
</code></pre>

<p>Para hacer las cosas interesantes introduciremos un método público en <code>miobjeto.h</code> para que podamos probar valores privados después de desenvolver el objeto:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#ifndef MIOBJETO_H
#define MIOBJETO_H

#include &lt;node.h&gt;

class MiObjeto : public node::ObjectWrap {
 public:
  static void Init();
  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);
  double Val() const { return val_; }

 private:
  MiObjeto();
  ~MiObjeto();

  static v8::Persistent&lt;v8::Function&gt; constructor;
  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);
  double val_;
};

#endif
</code></pre>

<p>La implementación de <code>miobjeto.cc</code> es similar a la anterior:</p>

<pre><code>#define BUILDING_NODE_EXTENSION
#include &lt;node.h&gt;
#include 'miobjeto.h'

using namespace v8;

MiObjeto::MiObjeto() {};
MiObjeto::~MiObjeto() {};

Persistent&lt;Function&gt; MiObjeto::constructor;

void MiObjeto::Init() {
  // Prepara la plantilla del constructor
  Local&lt;FunctionTemplate&gt; plantilla = FunctionTemplate::New(New);
  plantilla-&gt;SetClassName(String::NewSymbol('MiObjeto'));
  plantilla-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  constructor = Persistent&lt;Function&gt;::New(plantilla-&gt;GetFunction ());
}

Handle&lt;Value&gt; MiObjeto::New(const Arguments&amp; args) {
  HandleScope scope;

  MiObjeto* objeto = new MiObjeto();
  objeto-&gt;val_ = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
  objeto-&gt;Wrap(args.This());

  return args.This();
}

Handle&lt;Value&gt; MiObjeto::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);

  return scope.Close(instance);
}
</code></pre>

<p>Lo puedes probar con:</p>

<pre><code>var agregado = require('./build/Release/agregado');

var obj1 = agregado.createObject(10);
var obj2 = agregado.createObject(20);
var resultado = agregado.suma(obj1, obj2);

console.log(resultado); // 30
</code></pre>

      </section>
    </div>
  </body>
</html>
