<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <title>Miapi-node por Nacho Pacheco</title>
  </head>
  <body>
    <header>
      <div class="container">
        <h1>Miapi-node</h1>
        <h2>Mi interpretación de la API de Node v0.8.8</h2>
      </div>
    </header>
    <div class="container">
      <section id="main_content">
<h1><abbr title="Buffer">Búfer</abbr></h1>

<pre><code>Estabilidad: 3 — Estable
</code></pre>

<p>El código JavaScript puro es amigable con Unicode pero no es bueno como dato binario.  Cuándo tratas con flujos <abbr title="Protocolo de control de transmisión">TCP</abbr> o con el sistema de archivos, es necesario manejar flujos de octetos. Node tiene varias estrategias para manipular, crear y consumir flujos de octetos.</p>

<p>Los datos sin procesar se almacenan en instancias de la clase <code>Buffer</code>. Un <abbr title="Buffer"><code>Búfer</code></abbr> es similar a un arreglo de enteros pero corresponde a una asignación de memoria específica fuera del montón V8. Un <abbr title="Buffer"><code>Búfer</code></abbr> no se puede redimensionar.</p>

<p>La clase <code>Buffer</code> es global, por lo que muy rara vez o nunca necesitas declarar <code>require('buffer')</code>.</p>

<p>La conversión entre <code>Buffer</code> y objetos <abbr title="string">cadena</abbr> JavaScript requiere un método de codificación explícito.  Aquí tienes las diferentes codificaciones.</p>

<ul>
<li><p><code>'ascii'</code> — solo para datos ASCII de 7 bits.  Este método de codificación es muy rápido, y desechará el bit más significativo si existe.
Ten en cuenta que esta codificación convierte un carácter <abbr title="null"><code>nulo</code></abbr> (<code>'�'</code> o <code>'\u0000'</code>) a <code>0x20</code> (el código de carácter de un espacio). Si quieres convertir un carácter <abbr title="null"><code>nulo</code></abbr> a <code>0x00</code>,  tendrías que usar <code>'utf8'</code>.</p></li>
<li><p><code>'utf8'</code> — Caracteres multibyte codificados en Unicode. Muchas páginas web y otros formatos de documento usan UTF-8.</p></li>
<li><p><code>'utf16le'</code> — 2 o 4 bytes, caracteres Unicode codificados en <code>little endian</code>.
Cuenta con soporte para los pares sustitutos (desde U+10000 a U+10FFFF).</p></li>
<li><p><code>'ucs2'</code> — Alias de <code>'utf16le'</code>.</p></li>
<li><p><code>'base64'</code> — Codifica cadenas en Base64.</p></li>
<li><p><code>'binary'</code> — Una manera de codificar datos binarios sin procesar a cadenas usando sólo los primeros 8 bits de cada carácter. Se desaconseja este método de codificación y lo deberías evitar en favor de objetos <code>Buffer</code> dónde sea posible. Esta codificación será eliminada en futuras versiones de Node.</p></li>
<li><p><code>'hex'</code> — Codifica cada byte como dos caracteres hexadecimales.</p></li>
</ul>

<h2>Clase: <code>Buffer</code></h2>

<p>La clase <code>Buffer</code> es un tipo global para procesar datos binarios directamente.
La puedes construir de varias maneras.</p>

<h3><code>new Buffer(</code><abbr title="size"><code>tamanio</code></abbr><code>)</code></h3>

<ul>
<li><abbr title="size"><code>tamanio</code></abbr> <abbr title="Number">Número</abbr></li>
</ul>

<p>Asigna un nuevo <abbr title="buffer"><code>búfer</code></abbr> de la cantidad de octetos especificada por <abbr title="size"><code>tamanio</code></abbr>.</p>

<h3><code>new Buffer(</code><abbr title="array"><code>arreglo</code></abbr><code>)</code></h3>

<ul>
<li><abbr title="array"><code>arreglo</code></abbr> <abbr title="Array">Arreglo</abbr></li>
</ul>

<p>Asigna un nuevo <abbr title="buffer"><code>búfer</code></abbr> usando un <abbr title="array"><code>arreglo</code></abbr> de octetos.</p>

<h3><code>new Buffer(</code><abbr title="string"><code>cadena</code></abbr><code>, [</code><abbr title="encoding"><code>codificacion</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="string"><code>cadena</code></abbr> <abbr title="String">Cadena</abbr> — cadena a codificar.</li>
<li><abbr title="encoding"><code>codificacion</code></abbr> <abbr title="String">Cadena</abbr> — codificación a usar, opcional.</li>
</ul>

<p>Destina un nuevo <abbr title="buffer"><code>búfer</code></abbr> conteniendo la <abbr title="string"><code>cadena</code></abbr> suministrada.
La <abbr title="encoding"><code>codificacion</code></abbr> predeterminada es <code>'utf8'</code>.</p>

<h3><code>buf.write(</code><abbr title="string"><code>cadena</code></abbr><code>, [</code><abbr title="offset"><code>desplazamiento</code></abbr><code>], [</code><abbr title="length"><code>largo</code></abbr><code>], [</code><abbr title="encoding"><code>codificacion</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="string"><code>cadena</code></abbr> <abbr title="String">Cadena</abbr> — datos a escribir al <code>búfer</code></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number"><code>Número</code></abbr>, opcional, predefinido: 0</li>
<li><abbr title="length"><code>largo</code></abbr> <abbr title="Number"><code>Número</code></abbr>, opcional, predefinido: <code>buffer.length</code> — <abbr title="offset"><code>desplazamiento</code></abbr></li>
<li><abbr title="encoding"><code>codificacion</code></abbr> <abbr title="String">Cadena</abbr>, opcional, predefinida: 'utf8'</li>
</ul>

<p>Escribe <abbr title="string"><code>cadena</code></abbr> al <abbr title="buffer"><code>búfer</code></abbr> en <abbr title="offset"><code>desplazamiento</code></abbr> utilizando la codificación suministrada.
<abbr title="offset"><code>desplazamiento</code></abbr> predeterminado a <code>0</code>, <abbr title="encoding"><code>codificacion</code></abbr> predefinida a <code>'utf8'</code>. <abbr title="length"><code>largo</code></abbr> es la cantidad de bytes a escribir. Devuelve el número de octetos escritos. Si <abbr title="buffer"><code>búfer</code></abbr> no contiene suficiente espacio para que quepa la cadena entera, la escribe parcialmente. <abbr title="length"><code>largo</code></abbr> predeterminado a <code>buffer.length</code> — <abbr title="offset"><code>desplazamiento</code></abbr>.
El método no escribe caracteres parciales.</p>

<pre><code>bufer = new Buffer(256);
largo = bufer.write('\u00bd + \u00bc = \u00be', 0);
console.log(largo + ' bytes: ' + bufer.toString('utf8', 0, largo));
</code></pre>

<p>La cantidad de caracteres escritos (esta puede ser diferente a la cantidad de bytes escritos) se fija en <code>Buffer._charsWritten</code> y se sobrescribirá la siguiente vez que <code>bufer.write()</code> sea llamada.</p>

<h3><code>buf.toString([</code><abbr title="encoding"><code>codificacion</code></abbr><code>], [</code><abbr title="start"><code>inicio</code></abbr><code>], [</code><abbr title="end"><code>fin</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="encoding"><code>codificacion</code></abbr> <abbr title="String">Cadena</abbr>, opcional, predefinida: 'utf8'</li>
<li><abbr title="start"><code>inicio</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: 0</li>
<li><abbr title="end"><code>fin</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: <code>bufer.length</code></li>
</ul>

<p>Decodifica y regresa una cadena con los datos del búfer cifrados con <abbr title="encoding"><code>codificacion</code></abbr> (predeterminada a <code>'utf8'</code>) comienza en <abbr title="start"><code>inicio</code></abbr> (predefinido a <code>0</code>) y termina en
<abbr title="end"><code>fin</code></abbr> (predeterminado a <code>buffer.length</code>).</p>

<p>Ve el ejemplo de <code>buffer.write()</code>, arriba.</p>

<h3><code>buf[</code><abbr title="index"><code>indice</code></abbr><code>]</code></h3>

<!-- type=property -->
<!-- name=[index] -->

<p>Obtiene y fija el octeto en <abbr title="index"><code>indice</code></abbr>. Los valores se refieren a bytes individuales, así que el rango legal es entre <code>0x00</code> y <code>0xFF</code> en hexadecimal o entre <code>0</code> y <code>255</code>.</p>

<p>Ejemplo: Copia una cadena ASCII a un <code>búfer</code>, un byte a la vez:</p>

<pre><code>var cadena = 'node.js';
var bufer = new Buffer(cadena.length);

for (var i = 0; i &lt; cadena.length ; i++) {
  bufer[i] = cadena.charCodeAt(i);
}

console.log(bufer);

// node.js
</code></pre>

<h3>Método de clase: <code>Buffer.isBuffer(</code><abbr title="obj"><code>objeto</code></abbr><code>)</code></h3>

<ul>
<li><abbr title="obj"><code>objeto</code></abbr> <abbr title="Object">Objeto</abbr></li>
<li>Devuelve: <abbr title="Boolean">Booleano</abbr></li>
</ul>

<p>Comprueba si <abbr title="obj"><code>objeto</code></abbr> es un <code>Buffer</code>.</p>

<h3>Método de clase: <code>Buffer.byteLength(</code><abbr title="string"><code>cadena</code></abbr><code>,</code> <abbr title="encoding"><code>codificacion</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="string"><code>cadena</code></abbr> <abbr title="String">Cadena</abbr></li>
<li><abbr title="encoding"><code>codificacion</code></abbr> <abbr title="String">Cadena</abbr>, opcional, predefinida: 'utf8'</li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Proporciona la longitud real de una cadena en bytes. La <abbr title="encoding"><code>codificacion</code></abbr> predeterminada es <code>'utf8'</code>.
Este no es el mismo que <code>String.prototype.length</code> puesto que aquel regresa la cantidad de <em>caracteres</em> en una cadena.</p>

<p>Ejemplo:</p>

<pre><code>var cadena = '\u00bd + \u00bc = \u00be';

console.log(cadena + ': ' + cadena.length + ' caracteres, ' +
  Buffer.byteLength(cadena, 'utf8') + ' bytes');

// ½ + ¼ = ¾: 9 caracteres, 12 bytes
</code></pre>

<h3>Método de clase: <code>Buffer.concat(</code><abbr title="list"><code>lista</code></abbr><code>, [</code><abbr title="totalLength"><code>longitudTotal</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="list"><code>lista</code></abbr> {<abbr title="Array">Arreglo</abbr>} Lista de objetos <code>Buffer</code> a concatenar</li>
<li><abbr title="totalLength"><code>longitudTotal</code></abbr> {<abbr title="Number">Número</abbr>} Longitud total de los <code>búferes</code> cuándo se hayan concatenado</li>
</ul>

<p>Devuelve el <code>búfer</code> resultante después de concatenar todos los <code>búferes</code> en la lista.</p>

<p>Si la lista no tiene ningún elemento, o si <abbr title="totalLength"><code>longitudTotal</code></abbr> es 0, entonces regresa un <code>búfer</code> de longitud cero.</p>

<p>Si la lista tiene exactamente un elemento, entonces devuelve el primer elemento de la lista.</p>

<p>Si la lista tiene más de un elemento, entonces crea un nuevo <abbr title="buffer"><code>búfer</code></abbr>.</p>

<p>Si no suministras la <abbr title="totalLength"><code>longitudTotal</code></abbr>, esta se lee desde los <code>búferes</code> en la lista.
No obstante, esto añade un bucle adicional a la función, por lo tanto es más rápido proporcionar la longitud explícitamente.</p>

<h3><code>buf.length</code></h3>

<ul>
<li><abbr title="Number">Número</abbr></li>
</ul>

<p>El tamaño del <code>búfer</code> en bytes.  Ten en cuenta que este no necesariamente es el tamaño del contenido. <abbr title="length"><code>largo</code></abbr> se refiere a la cantidad de memoria destinada para el objeto <code>buffer</code>.  Esta no cambia cuándo se modifica el contenido del <abbr title="buffer"><code>búfer</code></abbr>.</p>

<pre><code>var bufer = new Buffer(1234);

console.log(bufer.length);
bufer.write('alguna cadena', 0, 'ascii');
console.log(bufer.length);

// 1234
// 1234
</code></pre>

<h3><code>buffer.copy(</code><abbr title="targetBuffer"><code>buferDestino</code></abbr><code>, [</code><abbr title="targetStart"><code>inicioDestino</code></abbr><code>], [</code><abbr title="sourceStart"><code>inicioFuente</code></abbr><code>], [</code><abbr title="sourceEnd"><code>finFuente</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="targetBuffer"><code>buferDestino</code></abbr> <abbr title="Object"><code>Objeto</code></abbr> <code>Buffer</code> — El <code>búfer</code> en el cual copiar</li>
<li><abbr title="targetStart"><code>inicioDestino</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: 0</li>
<li><abbr title="sourceStart"><code>inicioFuente</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: 0</li>
<li><abbr title="sourceEnd"><code>finFuente</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: <code>bufer.length</code></li>
</ul>

<p>Hace la copia entre <code>búferes</code>. Las regiones fuente y destino se pueden traslapar.
<abbr title="targetStart"><code>inicioDestino</code></abbr> e <abbr title="sourceStart"><code>inicioFuente</code></abbr> de manera predeterminada son <code>0</code>.
<abbr title="sourceEnd"><code>finFuente</code></abbr> por omisión es <code>buffer.length</code>.</p>

<p>Ejemplo: Construye dos <code>Búferes</code>, luego copia desde el byte 16 hasta el byte 19 de <code>buf1</code> a <code>buf2</code>, empezando en el 8º byte de <code>buf2</code>.</p>

<pre><code>var buf1 = new Buffer(26);
var buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26; i++) {
  buf1[i] = i + 97; // 97 es la 'a' en ASCII
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!
</code></pre>

<h3><code>buf.slice([</code><abbr title="start"><code>inicio</code></abbr><code>], [</code><abbr title="end"><code>fin</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="start"><code>inicio</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: 0</li>
<li><abbr title="end"><code>fin</code></abbr> <abbr title="Number">Número</abbr>, opcional, predefinido: <code>bufer.length</code></li>
</ul>

<p>Devuelve un nuevo <abbr title="buffer"><code>búfer</code></abbr> el cuál se refiere a la misma memoria que el anterior, pero desplazado y recortado por los índices <abbr title="start"><code>inicio</code></abbr> (predefinido a <code>0</code>) y <abbr title="end"><code>fin</code></abbr> (predefinido a <code>buffer.length</code>).</p>

<p><strong>¡Modificar la nueva porción del búfer modificará la memoria en el búfer original!</strong></p>

<p>Ejemplo: Construye un <abbr title="buffer"><code>búfer</code></abbr> con el alfabeto ASCII, toma una porción, luego modifica un byte del <abbr title="buffer"><code>búfer</code></abbr> original.</p>

<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26; i++) {
  buf1[i] = i + 97; // 97 es la 'a' en ASCII
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// abc
// !bc
</code></pre>

<h3><code>buf.readUInt8(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 8 bits sin signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42
</code></pre>

<h3><code>buf.readUInt16LE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readUInt16BE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 16 bits sin signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223
</code></pre>

<h3><code>buf.readUInt32LE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readUInt32BE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 32 bits sin signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403
</code></pre>

<h3><code>buf.readInt8(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 8 bits con signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.readUInt8</code>, salvo que el contenido del <code>búfer</code> se procesa como dos valores complementarios con signo.</p>

<h3><code>buf.readInt16LE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readInt16BE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 16 bits con signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.readUInt16*</code>, excepto que el contenido del <code>búfer</code> se trata como dos valores complementados con signo.</p>

<h3><code>buf.readInt32LE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readInt32BE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un entero de 32 bits con signo del <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.readUInt32*</code>, excepto que el contenido del <code>búfer</code> se procesa como dos valores complementarios con signo.</p>

<h3><code>buf.readFloatLE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readFloatBE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un número de 32 bits en punto flotante desde el <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01
</code></pre>

<h3><code>buf.readDoubleLE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.readDoubleBE(</code><abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
<li>Devuelve: <abbr title="Number">Número</abbr></li>
</ul>

<p>Lee un doble de 64 bits desde el <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación del <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code>. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333
</code></pre>

<h3><code>buf.writeUInt8(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 8 bits sin signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(bufer);

// &lt;Buffer 03 04 23 42&gt;
</code></pre>

<h3><code>buf.writeUInt16LE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeUInt16BE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 16 bits sin signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(bufer);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(bufer);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;
</code></pre>

<h3><code>buf.writeUInt32LE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeUInt32BE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 32 bits sin signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(bufer);

buf.writeUInt32LE(0xfeedface, 0);

console.log(bufer);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;
</code></pre>

<h3><code>buf.writeInt8(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 8 bits con signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.writeUInt8</code>, salvo que el valor se escribe en el <code>búfer</code> como dos valores enteros complementados con signo.</p>

<h3><code>buf.writeInt16LE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeInt16BE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 16 bits con signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.writeUInt16*</code>, salvo que el valor se escribe en el <code>búfer</code> como dos valores enteros complementados con signo.</p>

<h3><code>buf.writeInt32LE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeInt32BE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un entero de 32 bits con signo válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Trabaja como <code>buffer.writeUInt32*</code>, salvo que el valor se escribe en el <code>búfer</code> como dos valores enteros complementados con signo.</p>

<h3><code>buf.writeFloatLE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeFloatBE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un número en punto flotante de 32 bits válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(bufer);

buf.writeFloatLE(0xcafebabe, 0);

console.log(bufer);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;
</code></pre>

<h3><code>buf.writeDoubleLE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<h3><code>buf.writeDoubleBE(</code><abbr title="value"><code>valor</code></abbr><code>,</code> <abbr title="offset"><code>desplazamiento</code></abbr><code>, [</code><abbr title="noAssert"><code>noAcertar</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr></li>
<li><abbr title="noAssert"><code>noAcertar</code></abbr> <abbr title="Boolean">Booleano</abbr>, opcional, predefinido: <code>false</code></li>
</ul>

<p>Escribe <abbr title="value"><code>valor</code></abbr> al <code>búfer</code> en el <abbr title="offset"><code>desplazamiento</code></abbr> especificado con el formato <code>endian</code> predeterminado. Ten en cuenta que el <abbr title="value"><code>valor</code></abbr> tiene que ser un doble de 64 bits válido.</p>

<p>Ajusta <abbr title="noAssert"><code>noAcertar</code></abbr> a <code>true</code> para evadir la validación de <abbr title="value"><code>valor</code></abbr> y <abbr title="offset"><code>desplazamiento</code></abbr>. Esto significa que el <abbr title="value"><code>valor</code></abbr> puede ser demasiado grande para la función específica y el <abbr title="offset"><code>desplazamiento</code></abbr> puede estar más allá del final del <code>búfer</code> lo cual conduce a que se descarten los valores silenciosamente. No lo deberías usar a no ser que estés completamente seguro de su exactitud. De manera predeterminada es <code>false</code>.</p>

<p>Ejemplo:</p>

<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(bufer);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(bufer);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
</code></pre>

<h3><code>buf.fill(</code><abbr title="value"><code>valor</code></abbr><code>, [</code><abbr title="offset"><code>desplazamiento</code></abbr><code>], [</code><abbr title="end"><code>fin</code></abbr><code>])</code></h3>

<ul>
<li><abbr title="value"><code>valor</code></abbr></li>
<li><abbr title="offset"><code>desplazamiento</code></abbr> <abbr title="Number">Número</abbr>, opcional</li>
<li><abbr title="end"><code>fin</code></abbr> <abbr title="Number">Número</abbr>, opcional</li>
</ul>

<p>Llena el <code>búfer</code> con el <abbr title="value"><code>valor</code></abbr> especificado. Si no suministras el <abbr title="offset"><code>desplazamiento</code></abbr> (predefinido a <code>0</code>) y <abbr title="end"><code>fin</code></abbr> (predefinido a <code>buffer.length</code>) llenará el <code>búfer</code> entero.</p>

<pre><code>var b = new Buffer(50);
b.fill('h');
</code></pre>

<h2><code>buffer.INSPECT_MAX_BYTES</code></h2>

<ul>
<li><abbr title="Number">Número</abbr>, predefinido: 50</li>
</ul>

<p>Cuántos bytes devolverá al invocar a <code>buffer.inspect()</code>. Esto lo pueden redefinir los módulos del usuario.</p>

<p>Ten en cuenta que se trata de una propiedad en el módulo <code>buffer</code> devuelta por <code>require('buffer')</code>, no en el <code>buffer</code> global, o en una instancia de <code>buffer</code>.</p>

<h2>Clase: <code>SlowBuffer</code></h2>

<p>Esta clase primordialmente es para uso interno.  Los programas de JavaScript tendrían que utilizar <code>Buffer</code> en vez de utilizar <code>SlowBuffer</code>.</p>

<p>Para evitar la sobrecarga de destinar muchos objetos <code>Buffer</code> C++ para pequeños bloques de memoria en el tiempo de vida de un servidor, Node destina fragmentos de memoria de 8Kb (8192 byte).  Si un <code>búfer</code> es más pequeño de ese tamaño, entonces se respalda en un objeto <code>SlowBuffer</code> padre.  Si es más grande que esto, entonces Node le destinará un bloque <code>SlowBuffer</code> directamente.</p>

      </section>
    </div>
  </body>
</html>
